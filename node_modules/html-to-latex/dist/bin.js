#!/usr/bin/env node
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var program = _interopDefault(require('sywac'));
var path = require('path');
var parse5 = require('parse5');
var entities = require('entities');
var fsExtra = require('fs-extra');
var got = require('got');
var stream = require('stream');
var util = require('util');
var fs = require('fs');
var shortid = require('shortid');
var upath = require('upath');

const nls = (text) => `${text}\n`;
const nlp = (text) => `\n${text}`;

const centerblk = (text) => `\\begin{center}\n\t${text}\n\\end{center}`;
const centering = (text) => `\\centering{${text}}`;

const section = (text) => `\\section*{${centering(text)}}`;
const subsection = (text) => `\\subsection*{${text}}`;
const subsubsection = (text) => `\\subsubsection*{${text}}`;

const bold = (text) => `\\textbf{${text}}`;
const italic = (text) => `\\textit{${text}}`;
const underline = (text) => `\\underline{${text}}`;

const divider = nls('\\hrule');

const enumerate = (text) => `\\begin{enumerate}\n${text}\n\\end{enumerate}`;
const itemize = (text) => `\\begin{itemize}\n${text}\n\\end{itemize}`;
const item = (text) => `\t\\item ${text}`;
function image(path, { width, height, keepRatio, center } = { center: true }) {
  const line = ['\\includegraphics'];
  const options = [];

  if (width) options.push(`width=${width}`);
  if (height) options.push(`height=${height}`);
  if ((width || height) && keepRatio) options.push('keepaspectratio');
  if (options.length) line.push(`[${options.join(',')}]`);

  line.push(`{${upath.normalizeSafe(path)}}`);

  return center ? centerblk(line.join('')) : line.join('');
}

function usePackages(packageNames) {
  return nls(packageNames.map((n) => `\\usepackage{${n}}`).join('\n'));
}

function beginDocument({ title, includeDate = false, author } = {}) {
  const beginningText = [];

  if (title) beginningText.push(`\\title{${title}}`);
  if (author) beginningText.push(`\\author{${author}}`);
  if (includeDate) beginningText.push(`\\date{\\today}`);

  if (beginningText.length) beginningText.push(nlp(`\\begin{document}`));
  else beginningText.push(`\\begin{document}`);

  if (title) beginningText.push(nlp('\\maketitle'));

  return beginningText.join('\n');
}

const endDocument = nlp('\\end{document}');
const docClass = (className) => `\\documentclass{${className}}`;

const pipeline = util.promisify(stream.pipeline);

function analyzeForPackageImports(HTMLText) {
  const pkgs = [];

  if (HTMLText.includes('\\cfrac')) pkgs.push('amsmath');
  if (HTMLText.includes('<img')) pkgs.push('graphicx');
  if (HTMLText.includes('\\therefore')) pkgs.push('amssymb');

  return pkgs;
}

async function exportFile(text, filename, path$1 = process.cwd) {
  return fsExtra.outputFile(path.resolve(path$1, `${filename}.tex`), text);
}

async function convertImage(
  node,
  {
    compilationDir,
    autoGenImageNames = true,
    imageWidth,
    imageHeight,
    keepImageAspectRatio,
    centerImages = true,
    debug,
  } = {},
) {
  const imagesDir = path.resolve(compilationDir, 'images');
  const origPath = node.attrs.find(({ name }) => name === 'src').value;
  const ext = path.extname(origPath) || '.jpg';
  const base = autoGenImageNames ? `${shortid.generate()}${ext}` : path.basename(origPath);
  const localPath = path.resolve(imagesDir, base);
  const localLatexPath = path.join('images', base);
  const exists = await fsExtra.pathExists(localPath);

  if (!exists) {
    try {
      const url = new URL(origPath);

      await fsExtra.ensureDir(imagesDir);

      await pipeline(got.stream(url.href), fs.createWriteStream(localPath));
    } catch (e) {
      if (debug) {
        console.debug(`URL: ${origPath}`);
        console.debug(e);
      }
    }
  }

  return image(localLatexPath, {
    width: imageWidth,
    height: imageHeight,
    keepRatio: keepImageAspectRatio,
    center: centerImages,
  });
}

function convertPlainText(value, opts) {
  const breakReplacement = opts.ignoreBreaks ? '' : '\n\n';
  const cleanText = value
    .replace(/(\n|\r)/g, breakReplacement) // Standardize line breaks or remove them
    .replace(/\t/g, '') // Remove tabs
    .replace(/(?<!\\)%/g, '\\%');
  const decodedText = entities.decodeHTML(cleanText);

  return opts.preferDollarInlineMath ? decodedText.replace(/\\\(|\\\)/g, '$') : decodedText;
}

async function convertRichTextSingle(n, opts) {
  switch (n.nodeName) {
    case 'img':
      return convertImage(n, opts);
    case 'b':
    case 'strong':
      return convertRichText(n, opts).then((t) => bold(t));
    case 'i':
      return convertRichText(n, opts).then((t) => italic(t));
    case 'u':
      return convertRichText(n, opts).then((t) => underline(t));
    case 'br':
      return opts.ignoreBreaks ? ' ' : '\n\n';
    case 'span':
      return convertRichText(n, opts);
    case '#text':
      return convertPlainText(n.value, opts);
    default:
      return '';
  }
}

async function convertRichText(node, opts) {
  if (node.childNodes && node.childNodes.length > 0) {
    const converted = await Promise.all(node.childNodes.map((n) => convertRichTextSingle(n, opts)));
    return converted.join('');
  }

  return convertRichTextSingle(node, opts);
}

async function convertUnorderedLists({ childNodes }, opts) {
  const filtered = await childNodes.filter(({ nodeName }) => nodeName === 'li');
  const texts = await Promise.all(
    filtered.map((f) => convert([f], { ...opts, includeDocumentWrapper: false })),
  );
  const listItems = texts.map(item);

  return itemize(listItems.join('\n'));
}

async function convertOrderedLists({ childNodes }, opts) {
  const filtered = await childNodes.filter(({ nodeName }) => nodeName === 'li');
  const texts = await Promise.all(
    filtered.map((f) => convert([f], { ...opts, includeDocumentWrapper: false })),
  );
  const listItems = texts.map(item);

  return enumerate(listItems.join('\n'));
}

async function convertHeading(node, opts) {
  const text = await convertRichText(node, opts);

  switch (node.nodeName) {
    case 'h1':
      return section(text);
    case 'h2':
      return subsection(text);
    default:
      return subsubsection(text);
  }
}

async function convert(
  nodes,
  {
    autoGenImageNames = true,
    includeDocumentWrapper = false,
    documentClass = 'article',
    includePackages = [],
    compilationDir = process.cwd(),
    ignoreBreaks = true,
    preferDollarInlineMath = false,
    skipWrappingEquations = false,
    debug = false,
    imageWidth,
    imageHeight,
    keepImageAspectRatio,
    centerImages,
    title,
    includeDate,
    author,
  } = {},
) {
  const blockedNodes = [
    'h1',
    'h2',
    'h3',
    'ul',
    'ol',
    'img',
    'hr',
    'div',
    'section',
    'body',
    'html',
    'header',
    'footer',
    'aside',
    'p',
  ];
  const doc = [];
  const opts = {
    compilationDir,
    ignoreBreaks,
    preferDollarInlineMath,
    skipWrappingEquations,
    autoGenImageNames,
    debug,
    imageWidth,
    imageHeight,
    keepImageAspectRatio,
    centerImages,
  };
  let tempInlineDoc = [];

  if (includeDocumentWrapper) {
    doc.push(docClass(documentClass));

    if (includePackages.length > 0) doc.push(usePackages(includePackages));

    doc.push(beginDocument({ title, includeDate, author }));
  }

  nodes.forEach(async (n) => {
    if (!blockedNodes.includes(n.nodeName)) {
      tempInlineDoc.push(convertRichText(n, opts));
      return;
    }

    if (tempInlineDoc.length > 0) {
      doc.push(Promise.all(tempInlineDoc).then((t) => t.join('').trim()));
      tempInlineDoc = [];
    }

    switch (n.nodeName) {
      case 'h1':
      case 'h2':
      case 'h3':
        doc.push(convertHeading(n, opts));
        break;
      case 'ul':
        doc.push(convertUnorderedLists(n, opts));
        break;
      case 'ol':
        doc.push(convertOrderedLists(n, opts));
        break;
      case 'img':
        doc.push(convertImage(n, opts));
        break;
      case 'hr':
        doc.push(divider);
        break;
      case 'div':
      case 'section':
      case 'body':
      case 'html':
      case 'header':
      case 'footer':
      case 'aside':
        doc.push(
          convert(n.childNodes, {
            ...opts,
            includeDocumentWrapper: false,
          }),
        );
        break;
      case 'p':
        doc.push(
          convertRichText(n, opts).then((t) => {
            const trimmed = t.trim();

            // Check if text is only an equation. If so, switch \( \) & $ $, for \[ \]
            if (
              !opts.skipWrappingEquations &&
              trimmed.match(/^(\$|\\\()/) &&
              trimmed.match(/(\\\)|\$)$/)
            ) {
              const rewrapped = trimmed.replace(/^(\$|\\\()/, '\\[').replace(/(\\\)|\$)$/, '\\]');

              // TODO: Move all of this into the above regex check
              if (!rewrapped.includes('$')) return rewrapped;
            }

            return trimmed;
          }),
        );
        break;
    }
  });

  // Insert any left over inline nodes
  if (tempInlineDoc.length > 0) {
    doc.push(Promise.all(tempInlineDoc).then((t) => t.join('').trim()));
  }

  // Add document wrapper if configuration is set
  if (includeDocumentWrapper) doc.push(endDocument);

  const converted = await Promise.all(doc);

  return converted.filter(Boolean).join('\n\n');
}

async function convertText(data, options = {}) {
  const root = await parse5.parseFragment(data);

  return convert(root.childNodes, {
    ...options,
    includePackages: options.includePackages || analyzeForPackageImports(data),
  });
}

async function convertFile(filepath, { outputFilepath = filepath, ...options } = {}) {
  const data = await fsExtra.readFile(filepath, 'utf-8');
  const processed = await convertText(data, { includeDocumentWrapper: true, ...options });

  await exportFile(processed, outputFilepath, path.dirname(filepath));
}

// Add default settings
program
  .version('-v, --version')
  .help('-h, --help')
  .epilogue('Copyright 2020')
  .command('convert-file', {
    desc: 'Convert HTML to Latex',
    setup: (args) => {
      args
        .positional('[--ifp] <input-file>', {
          type: 'string',
        })
        .string('-ofp --output-file-path', {
          group: 'Output Options',
        })
        .boolean('-ib --ignore-breaks', {
          group: 'Parsing Options',
          defaultValue: true,
        })
        .boolean('-dm --prefer-dollar-inline-math', {
          group: 'Parsing Options',
          defaultValue: false,
        })
        .boolean('-swe --skip-wrapping-equations', {
          group: 'Parsing Options',
          defaultValue: false,
        })
        .boolean('-dw --include-document-wrapper', {
          group: 'Parsing Options',
          defaultValue: false,
        })
        .string('-dc --document-class', {
          group: 'Parsing Options',
          defaultValue: 'article',
        })
        .array('-ip --include-packages', {
          group: 'Parsing Options',
        })
        .string('-t --title', {
          group: 'Parsing Options',
        })
        .string('-a --author', {
          group: 'Parsing Options',
        })
        .boolean('-d --include-date', {
          group: 'Parsing Options',
        })
        .string('-cdr --compilation-dir', {
          group: 'Image Parsing Options',
          default: process.cwd(),
        })
        .boolean('-ain --autogen-image-names', {
          group: 'Image Parsing Options',
          defaultValue: true,
        })
        .string('-iw --image-width', {
          group: 'Image Parsing Options',
        })
        .string('-ih --image-height', {
          group: 'Image Parsing Options',
        })
        .boolean('-kar --keep-image-aspect-ratio', {
          group: 'Image Parsing Options',
          default: false,
        })
        .boolean('--debug', {
          group: 'Image Parsing Options',
          defaultValue: false,
        });
    },
    run: async (args) => {
      await convertFile(args.ifp, args.ofp, {
        autoGenImageNames: args.ain,
        includeDocumentWrapper: args.dw,
        documentClass: args.dc,
        includePackages: args.ip,
        compilationDir: args.cpr,
        preferDollarInlineMath: args.dm,
        skipWrappingEquations: args.swe,
        debug: args.debug,
        imageWidth: args.iw,
        imageHeight: args.ih,
        keepImageAspectRatio: args.kar,
        title: args.t,
        includeDate: args.d,
        author: args.a,
        ignoreBreaks: args.ib,
      });
    },
  });

// Parse input
program.parse().then(({ output }) => {
  console.log(output);
});
